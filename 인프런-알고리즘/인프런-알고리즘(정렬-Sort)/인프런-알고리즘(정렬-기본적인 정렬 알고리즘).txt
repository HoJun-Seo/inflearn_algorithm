기본적인 정렬 알고리즘

selection sort(선택 정렬)
배열내 원소들 중에서 가장 큰 값을 찾음
가장 큰 값을 제일 마지막 값과 자리를 바꾼다.(exchange)
똑같은 일은 나머지 데이터들 로 반복해준다.(매 반복마다 제일 마지막으로 옮겨간 원소는 다음 반복에서는 제외된다.)
제일 큰 값이 제일 마지막 값에 해당 할 경우 exchange 을 해주더라도 아무 일도 생기지 않는다.

슈도코드
selectionSort(A[], n) //배열 A[1....n] 을 정렬한다.
{
	for last <- n downto 2 {
		A[1....last] 중 가장 큰 수 A[k] 를 찾는다;
		A[k] <-> A[last]; //A[k] 와 A[last] 의 값을 교환한다.
	}
}
실행시간
- for loop 는 n-1 번 반복(n 부터 2까지 반복 됨)
- 가장 큰 수를 찾기 위한 비교횟수 : n - 1, n - 2, ..... , 2, 1 (last 개 에서 최대값을 찾기 위해서는 last - 1 번 비교해야 한다.)
- 교환은 상수 시간 작업
- 시간 복잡도 T(n) = (n - 1) + (n - 2) + .... + 2 + 1 = O(n^2) : 최악,최고,평균의 경우를 따질 필요가 없다.(세 가지 모두 똑같이 n(n - 1) / 2 만큼 소요된다.)	= n(n - 1) / 2

버블 정렬(bubble sort)
selection sort 와 기본 알고리즘은 유사하다.
가장 큰 값을 찾아 제일 마지막 자리로 옮겨온 후 나머지 데이터들에 대해 같은 일을 반복한다.
다만 최댓값을 찾아서 제일 마지막 자리로 가져오는 방법에 있어서 selection sort 와는 다르다.

첫번째 값에서 부터 시작해서 다음값과 비교
다음값보다 크면 서로간에 자리를 바꾼다.
그렇지 않으면 비교의 중심이 되는 원소를 다음 값으로 설정한후 다시 다음 값과 비교한다.(자리 교체 없음)
제일 마지막 위치까지 비교와 교체 작업이 끝나면 첫번째 반복이 끝난다.
결과적으로 배열 내부에서 최댓값이 배열 끝에서 부터 정렬되어 오름차순 정렬이 완성된다.
- 실행시간 : (n - 1) = (n - 2) + ...... + 2 + 1 = O(n^2)

슈도코드
bubbleSort(A[], n) { //배열 A[1....n] 을 정렬한다.
{
	for last <- n downto 2 {
		for i <- 1 to last - 1
			if(A[i] > A[i+1]) then A[i] <-> A[i+1];
	}
}
수행시간:
- for loop 는 n - 1 번 반복
- for loop 는 각각 n - 1, n - 2, ... , 2, 1 번 반복
- 교환은 상수시간 작업
T(n) = (n - 1) + (n - 2) + .... + 2 + 1 = O(n^2) = n(n - 1) / 2 
// 최악, 최고, 평균적인 경우든 상관없다.

삽입정렬(Insertion Sort)
정렬할 데이터에서 제일 첫번째 데이터 딱 하나만 있다면 그것은 일단 정렬이 되어 있다고 본다.
그 뒤에 다른 데이터를 넣어서 각 데이터 들을 정렬된 상태로 만들어 줘야 한다.
데이터가 추가 될 때마다 앞서 추가된 데이터 들간의 비교를 통해 배열을 정렬해준다.
각각 데이터의 추가로 인해 배열이 정렬될 시 정렬될 때마다 각 데이터들을 다시 움직여 줘야 한다.
추가된 데이터를 기존의 데이터들과 비교하면서 비교가 끝난 데이터는 우선적으로 움직여준다.(어차피 움직여서 정렬시켜야 함)
추가시킬 값은 임시로 변수를(tmp) 하나 생성하여 값을 복사해 둬야 한다. 이전에 추가된 데이터들을 움직일때 추가되는 데이터가 있던 위치로 옮겨가야 하기 때문이다.

슈도코드
insertionSort(A[], n) //배열 A[1...n] 을 정렬한다.
{
	for i <- 2 to n {
		A[1....i] 의 적당한 자리에 A[i] 를 삽입한다.
	}
}

수행시간 :
- for loop 는 n - 1 번 반복
- 삽입은 최악의 경우 i - 1 번 비교(이미 추가되어 있는 데이터들이 추가하는 데이터보다 모두 다 큰 경우, 앞에 있는 데이터들과 전부 비교해야 한다.)
- 최악의 경우 : T(n) = (n - 1) + (n - 2) + .... + 2 + 1 = O(n^2) = n(n - 1) / 2
bubble sort , selection sort 와 다른점 : 최악, 최고, 평균의 경우가 따로 존재한다.

		 