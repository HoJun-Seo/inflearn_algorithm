합병 정렬(merge sort)
분할 정복법(merge sort, quick sort) - divide and conquer

- 세 가지 단계를 거쳐 문제를 해결한다.
분할 : 해결하고자 하는 문제를 작은 크기의 동일한 문제들로 분할
정복 : 각각의 작은 문제를 순환적(recursion)으로 해결
합병 : 작은 문제의 해를 합하여(merge) 원래 문제에 대한 해를 구함.

입력으로 n 개의 데이터가 주어졌을 때 그중 최대값을 찾을때(recursion 할 당시) - 이진 탐색을 생각하면 됨.(반으로 분할 한 후 분할 한 각 파트에서 최댓값을 찾아보는 경우)
본질적으로 recursion 을 사용해서 문제를 해결하는 기법이기도 하다.

합병 정렬(merge sort)
데이터가 저장된 배열을 절반으로 나눔
각각을 순환적으로 정렬
정렬된 두 개의 배열을 합쳐(merge) 전체를 정렬

정렬된 배열 2개가 있을 때, 추가적으로 배열을 하나 더 생성하여 해당 배열 안에 정렬된 배열 2개를 merge 해 준다.
2개의 배열에서 각 원소 별로 비교를 해준다.
각 배열의 첫번째 원소끼리 비교하여 더 작은 값이 먼저 추가된 배열에 삽입되고 삽입되지 않은 다른 배열의 첫번째 원소는, 첫번째 원소가 삽입된 다른 배열의 두번째 원소와 다시 값을 비교하는 방식으로 합병 정렬을 완료한다.
한쪽 배열에서 모든 원소들이 추가된 배열에 먼저 모두 삽입되면 아직 원소가 남아있는 다른 배열은 자동으로 남아 있는 원소들을 추가된 배열의 제일 뒤에서 부터 모두 삽입해 넣는다.
   
mergeSort(A[], p, r) //A[p...r] 을 정렬한다.
{
	iif(p < r) then {
		q <- (p + q) / 2; //p, q 의 중간 지점 계산
		mergeSort(A, p, q) //전반부 정렬
		mergeSort(A, q + 1, r) //후반부 정렬
		merge(A, p, q, r); //합병
	}
}
merge(A[], p, q, r)
{
	정렬되어 있는 두 배열 A[p....q] 와 A[q + 1 ..... r] 을 합하여
	정렬된 하나의 배열 A[p....r] 을 만든다.
}

T(n) = 
if n = 1 : 0
otherwise : T([n / 2]//앞쪽 배열) + T([n/2]//뒤쪽 배열) + n(마지막 n 은 정렬된 원소들을 배열에 삽입하는 데 걸리는 시간)
 = O(nlogn)
n/2 -> n/4 + n/4 -> n/8 + n/8 + n/8 + n/8....
T(n/2^k) 

