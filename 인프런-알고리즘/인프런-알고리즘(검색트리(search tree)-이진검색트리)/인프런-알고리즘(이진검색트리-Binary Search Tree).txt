이진 검색트리 - Binary Search Tree

Dynamic Set(집합) - 데이터들이 고정되어 있지 않고 새로 추가 되거나, 기존의 데이터들이 삭제되는 등 데이터들이 계속해서 변화한다.
여러개의 키(key)를 저장
다음과 같은 연산즐을 지원하는 자료구조
- INSERT - 새로운 키의 삽입
- SEARCH - 키 탐색
- DELETE - 키의 삭제
예시 : 심볼 테이블
called Dynamic Set, Dictionary, or Search Structure(여러개의 데이터를 저장하고 있으면서 search performance 를 효율적으로 다루고, 그러면서 데이터의 삽입, 삭제또한 가능한 자료구조)
배열 이나 연결리스트를 사용해 볼 수 있다.

배열을 사용할 경우 옵션
배열을 정렬하거나 정렬한 상태로 데이터들을 넣을 수 있음
연결리스트 역시 마찬가지

배열에 데이터를 정렬하지 않는 경우 탐색 시간복잡도 : 순차탐색 O(n) - 최악의 경우
배열에 데이터를 정렬하지 않는 경우 삽입 시간복잡도 : 굳이 특정한 위치에 삽입할 이유가 없음, 맨 마지막 자리에 삽입 O(1)
일반적으로 배열은 크기가 고정되어 있기 때문에 더 이상 데이터를 넣을 수 없다면 보통 더 큰 배열을 잡아서 데이터들을 모두 옮겨야 한다. O(n)
배열에 데이터를 정렬하지 않는 경우 삭제 시간복잡도 : 삭제할 데이터 탐색, 찾은 데이터 삭제
삭제만을 따질 경우 정렬되어 있지 않기 때문에 데이터를 삭제 한 후 누가 해당 공간을 메워도 상관없음, 따라서 맨 마지막 데이터를 삭제한 자리로 가져와서 메우는 방식으로 할 수 있다. O(1) 

배열에 데이터가 정렬되어 있는 경우 탐색 시간복잡도 :  정렬되어 있는 경우 이진 탐색이 가능하므로 O(logn)
배열에 데이터가 정렬되어 있는 경우 삽입 시간복잡도 :  새로운 데이터를 삽입할 때 아무데나 삽입할 수 없으므로 정렬의 기준에 따라 데이터들을 움직여야 함 - 최악의 경우 O(n)
배열에 데이터가 정렬되어 있는 경우 삭제 시간복잡도 :  삽입과 같음 - 최악의 경우 맨 앞자리의 데이터가 삭제 되었을 시 남아있는 모든 데이터들이 움직여야 하므로 O(n)

연결리스트의 경우
정렬되어 있지 않은 경우 검색 : O(n)
정렬되어 있지 않은 경우 삽입 : 맨 앞에 삽입하는 것이 가장 간단함 O(1)
정렬되어 있지 않은 경우 삭제 : 검색하는 시간 제외 삭제 하는 것만 생각한다면 O(1)
//배열과 비교 하였을 때 연결리스트의 장점, 데이터의 삽입 삭제가 있을시 기존에 있던 데이터들을 움직여줄 필요가 없다.

정렬되어 있는 경우 검색 : 데이터 들이 크기 순으로 정렬 되어 있다고 해도 이진 탐색을 사용할 수 없음
이진 탐색은 단순히 데이터들이 크기 순으로 정렬되어 있다는 것만으로는 수행 할 수 없다.
가운데 데이터를 한번에 찾아서 꺼낼 수 있어야 하나 연결리스트에서는 n/2 번째 노드를 한번에 찾아갈 수가 없다.(순차적으로 따라가야함, 배열과 같은 인덱스가 없기 때문) - O(n)
정렬되어 있는 경우 삽입 : 삽입 할 자리를 찾아야 함, 자리를 찾는데 걸리는 최악의 경우 O(n)
정렬되어 있는 경우 삭제 : 삭제할 노드를 찾는 시간을 제외한다면 삭제하는 데는 O(1) 이면 충분하다.

배열이든 연결리스트든 데이터들이 정렬되어 있든 되어 있지 않든 Dynamic Set 을 구현하게 되면 적어도 하나는 O(n) 시간을 피할 수 없다.
- 정렬된 혹은 정렬되지 않은 배열 혹은 연결 리스트를 사용할 경우 INSERT, SEARCH, DELETE 중 적어도 하나는 O(n)
- 이진 탐색트리(Binary Search Tree), 레드-블랙 트리, AVL-트리 등의 트리에 기반한 구조들
- Direct Address Table, 해쉬 테이블등

검색트리
Dynamic set 을 트리의 형태로 구현한다.
일반적으로 SEARCH, INSERT, DELETE 연산이 트리의 높이(height) 에 비례하는 시간복잡도를 가진다.
이진 검색트리(Binary Search Tree), 레드-블랙 트리(red-black tree), B-tree 등

이진 검색트리(BST)
- 이진 트리이면서
- 각 노드에 하나의 키를 저장한다.
- 각 노드 v 에 대해서 그 노드의 왼쪽 부트리(subtree) 에 있는 키들은 key[v](v 에 저장된 key) 보다 작거나 같고, 오른쪽 부트리에 있는 값은 크거나 같다.

heap 과 bst 는 전혀 다르다.
heap 는 기본적으로 complete binary tree 여야 한다.
bst 는 트리가 특정한 모양을 가져야 할 필요가 없다.
Max heap 의 경우 max-heap property(트리에서 부모는 자식보다 크거나 같다) 를 만족해야 하지만
bst 의 경우 부모노드의 왼쪽에 있는 자식노드는 부모노드 보다 작거나 같고, 오른쪽에 있는 자식 노드는 부모노드 보다 크거나 같다.

슈도 코드
TREE-SEARCH(x,k) // k : 찾고 있는 값, x : 트리의 루트 노드
1. if x = NIL or k = key[x] //노드 x 에 저장되어 있는 값
2.	then return x
3. if k < key[x]
4.	then return TREE-SEARCH(left[x], k) //recursion
5.	else return TREE-SEARCH(right[x], k) //recursion
시간복잡도 : O(h), 여기서 h 는 트리의 높이

SEARCH - Iterative Version
ITERATIVE-TREE-SEARCH(x,k)
1. while x != NIL and k != key[x]
2.	do if k < key[x]
3.		then x <- left[x]
4.		else x <- right[x]
5. return x
시간복잡도 : O(h), 여기서 h는 트리의 높이(노드의 갯수가 n 개일때 트리의 높이 h가 얼마인지가 중요하다., 최악의 경우 h = n 이 될수도 있다.)

이진 검색트리의 최소값
TREE-MINIMUM(x)
1. while left[x] != NIL
2.	do x <- left[x]
3. return x
최소값은 항상 가장 왼쪽 노드에 존재한다.
시간복잡도 : O(h)

이진 검색트리의 최대값
TREE-MAXIMUM(x)
1. while right[x] != NIL
2.	do x <- right[x]
3. return x
최대값은 항상 가장 오른쪽 노드에 존재
시간복잡도 : O(h)

Successor
- 노드 x 의 successor 란 key[x] 보다 크면서 가장 작은 키를 가진 노드이다.(찾고자 하는 값보다 큰 값 중 가장 작은 값)
- 모든 키 들이 서로 다르다고 가정한다.
3가지 경우를 따져볼 수 있다.
- 노드 x 의 오른쪽 부트리가 존재할 경우, 오른쪽 부트리의 최소값(x 보다 큰 값 중 가장 작은 값 - 오른쪽 부트리로 간 후 더 이상 왼쪽 자식 노드가 나오지 않을 때까지 왼쪽 노드로 내려간다.)
- 오른쪽 부트리가 없는 경우, 어떤 노드 y 의 왼쪽 부트리의 최대값이 x가 되는 경우 노드 y 는(root node) x의 successor(왼쪽 부트리의 최대값 < 루트 노드)
- 그런 노드 y가 존재하지 않을 경우 successor 가 존재하지 않음(즉, x가 최대값)

슈도 코드
TREE-SUCCESSOR(x) //노드 x 의 successor 를 찾는다.
1. if right[x] != NIL //오른쪽 부트리가 존재할 경우
2.	then  return TREE-MINIMUM(right[x]) //해당 부트리에서 최소값을 찾는다.
3. y <- p[x] //오른쪽 부트리가 존재하지 않을 경우 p[x] : x 의 부모 노드
4. while y != NIL and x = right[y] //x 가 부모 노드 y 의 자식 노드인 동안
5.	do x <- y //x에 y값 저장
6.	    y <- p[y] //y 에 y의 부모 노드 값 저장
7. return y //x 가 y 노드의 왼쪽 자식이 되는 순간 반복문을 빠져나온다. (해당 하는 상황의 y값은 x 의 successor 이다.)
시간복잡도 : O(h)


Predecessor(Successor 의 반대)
노드 x 의 predecessor 란 key[x] 보다 작으면서 가장 큰 키를 가진 노드
Successor 와 반대이다.(Successor 의 수행과정을 반대로 바꾸면 Predecessor 를 수행 할 수 있다.), O(h)

INSERT
이진 검색트리는 새로운 노드를 추가 할 때 기존의 노드들을 전혀 변경하지 않는다는 특징이 있다.
새로운 노드를 추가 할 때는 기존 트리에서 leaf node 의 적절한 곳에 추가를 해주는 것으로 간편하게 해결한다.
해당 leaf node 의 위치는 루트 노드 부터 시작해서 적절한 위치를 탐색하며 찾아낸다.
실제로 구현할 때는 약간의 트릭이 필요하다.(2개의 포인터를 사용한다. x, y)
x 가 한 칸 내려가면 y 는 이전에 x 의 위치로 이동한다.(y 가 x 의 바로 뒤를 따라옴)
최종적으로 leaf node 에 도착했을 때 y 노드는 x 노드의 부모 노드로 취급 시킬 수 있다.

슈도 코드
TREE-INSERT(T, z) //T : bst, z : insert node
1. y <- NIL // 항상 x 의 뒤를 따라와야 하므로 첫 시작은 NULL
2. x <- root[T] //root[T] : root node 의 주소
3. while x != NIL // x 가 NULL 이 되는 순간, y 가 가리키고 있는 노드의 자식으로 새로운 노드를 insert 해준다.
4.	do y <- x
5.		if key[z] < key[x]
6.			then x <- left[x]
7.			else x <- right[x]
8. p[z] <- y //새로운 노드 z 의 부모 노드는 y 이다.
9. if y = NIL //예외의 경우 - 트리가 처음 부터 비어있어서 while 문을 거치지 않았을 경우
10.	then root[T] <- z //Tree T was empty (새로 추가되는 노드 z 가 root node 가 된다.)
11.	else if key[z] < key[y] // z 를 y의 자식 노드로 취급 되어야 하는 데, x 가 NULL 이 되어버렸기 때문에, x 가 왼쪽으로 가서 NULL 이 되었는지 오른쪽으로 가서 NULL 이 되었는지 모르므로 한번 더 비교를 해줘야 한다.
12.		then left[y] <- z
13.		else right[y] <- z
시간 복잡도 : O(h)


DELETE
- case 1 : 자식 노드가 없는 경우(leaf node 인 경우) -> 바로 삭제 할 수 있다.
실제로는 부모노드의 특정 방향 자식 노드의 필드를 NULL 로 바꿔준다.

- case 2 : 자식 노드가 1개 인 경우 -> 자신의 자식노드를 원래 자신의 위치로 옮긴다.

- case 3 : 자식노드가 2개인 경우 -> 삭제하려는 노드의 successor 는 최대 1개의 자식 노드를 가진다.
삭제하려는 노드 자체는 그대로 두고, 노드에 있는 데이터 자체만 삭제한다.
데이터가 없는 빈 노드로 둘 수는 없으므로 다른 노드에 있는 데이터를 옮겨온다.
요즘은 객체 지향 프로그래밍(OOP)을 많이 하면서 노드에 데이터를 직접 저장해두는것 보다 데이터가 저장되어 있는 객체의 주소를 저장해 두는 형태로 노드를 만든다.
데이터를 삭제한 노드에 다른 데이터를 가져올 때는 삭제한 데이터에 가장 가까운 값을 가져오는 것이 유리하다.(successor 또는 predeccessor)
 - 여기서 삭제는 successor 노드의 데이터를 해당 노드로 copy 해 오는 것으로 수행된다.
successor 는 곧 왼쪽 노드가 존재하지 않는다는 뜻 -> 삭제한 데이터보다 큰 값보다 가장 작은 값이므로(자식의 갯수가 0개거나 1개)
successor 의 데이터를 옮기고 나면 해당 노드를 대상으로 case 1 또는 case 2 의 방법으로 삭제 루틴을 수행한다.

슈도 코드
TREE-DELETE(T, z) // z : 삭제할 노드(주소는 이미 찾아서 넘겼다고 가정)
1. if left[z] = NIL or right[z] = NIL //왼쪽이나 오른쪽 자식이 NULL 이라면
2.	then y <- z
3.	else y <- TREE-SUCCESSOR(z) //자식 노드가 2개일 경우(y 는 실제로 삭제할 노드(z 의 successor))
4. if left[y] != NIL // 4 ~ 13 : 노드 y 를 삭제하는 과정
5.	then x <- left[y]
6.	else x <- right[y] //x 는 왼쪽 노드,오른쪽 노드 혹은 NULL 일 수도 있다.
7. if x != NIL
8.	then p[x] <- p[y] // y의 부모가 x 의 부모가 된다.(x 가 y의 위치로 옮겨감)
9. if p[y] = NIL // y의 부모가 NULL 이라면?(y 가 root node 임)
10.	then root[T] <- x // x가 트리의 root node 가 된다
11. 	else if y = left[p[y]] //y의 부모 노드가 있다면
12.		then left[p[y]] <- x
13.		else right[p[y]] <- x
14. if y !=z // case 3 에 해당되는지 아닌지를 검사한다.(y 가 처음에 삭제하려고 한 데이터가 아니라, 삭제하려고 하는 데이터의 successor 이다.)
15.	then key[z] <- key[y]
16.		copy y's satellite data into z //노드에 키 값만이 아니라 키 값에 붙어다니는 데이터들이 있다면 같이 y 로 옮겨줘야 한다.
17. return y
시간복잡도 : O(h)

- 각종 연산의 시간복잡도 O(h)
- 그러나 최악의 경우 트리의 높이 h = O(n)
- 균형잡힌(balanced) 트리
 : 레드-블랙 트리 등(만약의 경우에도 시간복잡도가 O(n) 을 넘지 않도록 만들어진 트리)
 : 키의 삽입이나 삭제시 추가로 트리의 균형을 잡아줌으로서 높이를 O(log2n) 으로 유지한다.