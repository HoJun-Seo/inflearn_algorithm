해싱-Hashing
Hash Table
- 해쉬 테이블은 dynamic set(탐색, 삽입, 삭제 의 3가지 연산을 지원하는 자료구조) 을 구현하는 효과적인 방법의 하나이다.
   - 적절한 가정하에서 평균 탐색, 삽입, 삭제시간 O(1)
   - 보통 최악의 경우 O(n)

해쉬 함수(hash function) h 를 사용하여 키 k 를 T[h(k)] 에 저장한다.(k를 저장할 위치를 계산하는 함수 : h)
해쉬 테이블은 일반적으로 하나의 배열이다.
크기가 m 인 해쉬 테이블은 일반적으로 크기가 m 인 배열이라고 생각하면 됨
- h : U -> {0, 1, ... , m -1},
  : 여기서 m 은 테이블의 크기, U 는 모든 가능한 키들의 집합
- 키 k 가 h(k) 로 해싱 되었다고 말한다.
* index = h(k) // 즉 각 키에 대한 해쉬함수 값을 그 키를 저장할 배열 인덱스로 사용한다.(해쉬 테이블의 주소)

해쉬 함수의 예시
- 모든 키들을 자연수라고 가정한다.(어떤 데이터든지 자연수로 해석하는 것이 가능)
- 예 : 문자열
  - ASCII 코드 : C = 67, L = 76, R = 82, S = 82
  - 문자열 CLRS 는(67 * 128^3) + (76 * 128^2) + (82 * 128) + (83 * 128^0) = 141,764,947
- 해쉬 함수의 간단한 예 :
  - h(k) = k % m, (즉 key 를 하나의 자연수로 해석한 후 테이블의 크기 m으로 나눈 나머지)
  - 항상 0 ~ m - 1 사이의 정수가 된다.

충돌(collision)
- 두 개 이상의 키가 동일한 위치로 해싱되는 경우
- 즉, 서로 다른 두 키 k1 과 k2 에 대해서 h(k1) = h(k2) 인 상황 (서로 다른 키 들의 해쉬 값이 동일한 경우)
- 일반적으로 |U| >> m 이므로 항상 발생 가능 (즉 단사함수가 아님) // m >= |U| 여야 단사함수(또는 일대일 함수)가 존재할 수 있다.
- 만약 |K| > m 이라면 당연히 발생한다.(여기서 K는 실제로 저장된 키 들의 집합)
- 충돌이 발생할 경우 대처 방법이 필요하다.
- 대표적인 두 가지 충돌 해결 방법 : chaining(seperate chaining), open addressing

테이블의 각 칸에 몇개의 데이터든 저장할 수 있다면 충돌이 더 이상 문제가 되지 않는다.
chaining 에 의한 충돌 해결
- 동일한 장소로 해싱된 모든 키들을 하나의 연결리스트(Linked List)로 저장한다.
- 키의 삽입(Insertion)
: 키 k 를 리스트 T[h(k)] 의 맨 앞에 삽입한다 - 시간복잡도 : O(1)
중복된 키가 들어올 수 있고, 중복 저장이 허용되지 않는다면 삽입 시 리스트를 검색해야 한다. 따라서 시간복잡도는 리스트의 길이에 비례한다.
- 키의 검색(Search)
: 리스트 T[h(k)] 에서 순차검색 한다.
시간복잡도는 키가 저장된 리스트의 길이에 비례한다.
- 키의 삭제(Deletion)
: 리스트 T[h(k)] 로부터 키를 검색 후 삭제한다.
 일단 키를 검색해서 찾은 후에는 O(1) 시간에 삭제 가능(단방향 연결리스트라면 약간의 테크닉이 필요하다.(리스트 사이에서 주소 간의 연결 관련 문제))

- 최악의 경우는 모든 키가 하나의 슬롯으로 해싱되는 경우
: 길이가 n 인 하나의 연결리스트가 만들어진다.
  따라서 최악의 경우 탐색시간은 O(n) + 해쉬함수 계산시간
평균 시간 복잡도는 키들이 여러 슬롯에 얼마나 잘 분배되느냐에 의해서 결정된다.
키들이 고르게 잘 분배될수록 각 슬롯 별로 생성되는 연결리스트의 길이가 짧아진다.

그러나 일반적으로 해쉬함수 에서 최악의 경우를 피해가는게 쉬운일이 아니다.
테이블의 크기 m, 모든 가능한 키들의 집합 U
U 에서 특정 키 i 번 슬롯으로 매핑되는 키 들(중복 매핑)의 부분집합의 크기는 적어도 |U|/m 보다 크거나 같다.
왜 ? U 개의 키들을 m 개의 집합으로 분할했으니까 그중에 적어도 어떤 한 집합은 |U|/m 이상이다.
일반적으로 U 는 m 보다 훨씬 크다. |U|/m 자체도 실제로 저장하는 데이터의 갯수 m 보다 크다고 가정할 수 있다.(U의 크기가 굉장히 크기 때문)
즉, |U| > m * n 이다. 어떤 해쉬함수를 만들더라도 모든 키들이 하나의 슬롯으로 매핑되는 최악의 경우가 존재할 수 밖에 없다.
따라서 해싱에서 최악의 경우 시간복잡도는 O(n) 이다. (해싱을 하는 한 어쩔수 없음)
그래서 해싱 함수를 다룰 때는 일반적으로 최악의 경우 보다는 평균적인 경우를 다루게 된다.

SUHA(Simple Uniform Hashing Assumption)
각각의 키가 모든 슬롯들에 균등한 확률로(equally likely) 독립적으로(independently) 해싱된다는 가정이다.
- 성능 분석을 위해서 주로 하는 가정이다.(현실에서는 실현 불가능한 알고리즘이다.)
- hash 함수는 deterministic(결정론적임 - 예측한 그대로 동작하는 알고리즘(키의 값은 확률적으로 변하는 것이 아니라 일정하다.)) 하므로 현실에서는 불가능하다.(해쉬 함수는 랜덤 함수가 아니다.) (키의 값이 항상 일정하므로 키의 값이 균등하게 분배된다는 것 자체가 말이 안됨)
- 현실적으로 가능한 가정은 해쉬 테이블에 대해 U 에서 키 값을 랜덤하게 저장한다면(해쉬 함수가 랜덤한게 아님, 키 값이 랜덤) 균등 분배가 가능하다.
그러나 충분하지 않은 가정이다.

Load factor a = n/m : // 키값 들이 균등하게 분배된다고 가정했을 경우
- n : 테이블에 저장될 키의 개수
- m : 해쉬 테이블의 크기, 즉 연결리스트의 개수
- 각 슬롯에 저장된 키의 평균 개수

연결리스트 T[j] 의 길이를 nj 라고 하면 E[nj] = a (하나의 키로 매핑될 키 들의 갯수의 평균은 Load factor 가 된다.)
만약 n = O(m) 이면 평균검색시간은 O(1)


open addressing 에 의한 충돌 해결
- 모든 키를 해쉬 테이블 자체에 저장한다.
- 테이블의 각 칸(slot) 에는 1개의 키만 저장한다.(open addressing 을 여러가지 방식으로 확장할 수 있기 때문에 꼭 그런것은 아니다.)
즉, 충돌이 생기면 자신이 원래 저장되어야 할 슬롯이 아니라 다른 슬롯에 저장 시켜야 한다.
- 충돌 해결기법
  - Linear probing
  - Quadratic probing
  - Double hashing

Linear probing
h(k), h(k) + 1, h(k) + 2, .....  순서로 검사하여 처음으로 빈 슬롯에 저장한다.
충돌이 발생하면 해당 위치에서 부터 시작하여 아래로 내려가면서 순차적으로 비어있는 슬롯을 탐색 한 후, 비어있는 슬롯을 발견하면 해당 위치에 키를 저장시킨다.
테이블의 끝에 도달하면 다시 처음으로 circular 하게 돌아간다.(다시 0번 슬롯으로 돌아가서 탐색한다.)
탐색을 할때는 내가 찾는 키가 찾아지거나 비어있는 슬롯이 나올때까지 연속해서 탐색한다.(슬롯이 비어있다면 그 다음에 찾는 키가 있을 수는 없다.)\
chaining 과의 공통점?
chaining 에서는 해싱을 한 다음 슬롯에 연결리스트로 저장되어 있으므로 연결리스트를 검색해야 한다면
open addressing 에서는 충돌이 발생한 슬롯 부터 빈 슬롯이 나올때까지 계속 검사를 해야한다.

Linear probing 의 단점
- primary cluster : 키에 의해서 채워진 연속된 슬롯들을 의미한다.
- 이런 cluster 가 생성되면 이 cluster 는 점점 더 커지는 경향이 생긴다.(cluster 가 커질수록 탐색 시간이 점점 길어진다. - cluster 가 커지면 커질수록 충돌이 발생할 가능성이 크기 때문) - 원래 본인이 저장되어야 할 슬롯에서 부터 점점 더 멀리 떨어지게 된다.

Quadratic probing
- 충돌 발생시 h(k), h(k) + 1^2, h(k) + 2^2, h(k) + 3^2, ....... 순서로 시도한다. <- 반드시 이런 형식으로 해야될 이유는 없다.
탐색 범위를 띄워 놓을 수 있다면 각종 방정식 등을 활용하며 변형을 해도 된다.

Double hashing
- 서로 다른 두 해쉬 함수 h1, h2 를 이용하여 h(k, i) = (h1(k) + i * h2(k)) mod m
i 의 값에 따라(0, 1, 2, .....) 위치 값을 다르게 가져간다.(기본적인 개념은 Quadratic probing 과 비슷하다.)
엄밀하게 말하면 두번째 해쉬 함수 h2 의 값이 0 이어서는 안된다. (i 가 0 이어서는 안된다, i = 1 부터 시작함)

Quadratic probing, Double hashing 의 차이점?
Quadratic probing : 모든 키에 대해서 +1, +4, +9 .....
Double hashing : 키 값에 따라 offset(탐색 간격) 이 달라진다.

open addressing - 키의 삭제
단순히 키를 삭제할 경우 문제가 발생한다.
- 가령 A2, B2, C2 가 순서대로 모두 동일한 해쉬 함수값을 가져서 Linear probing 으로 충돌을 해결할 경우
- B2 를 삭제한 후 C2 를 검색할 경우 문제가 발생한다.(C2 는 없다고 판단하게 된다.)
- 삭제한 위치에 원래 데이터가 있었음을 알리는 마킹을 남겨주면 문제를 해결 할 수 있겠으나 좋은 아이디어는 아니다.(결국 모든 빈칸들이 마킹으로 채워질 가능성이 있다.)
- 단순히 삭제만 하는 것이 아니라, 그 다음부터 연속하여 키를 탐색하며, 그 키들의 원래 해쉬 값이 삭제한 슬롯 보다 작거나 같은 키 값이 있다면 해당 키 값을 이전에 데이터를 삭제한 슬롯으로 옮겨오고, 옮김으로 인해 생겨난 빈칸에 대해서도 같은 작업을 반복한다.
또는 테이블의 제일 끝에서 부터 시작해서 삭제한 슬롯의 키값에 적합한 데이터를 옮겨오는 것이 가장 적절하다.

좋은 해쉬 함수란?
현실에서는 키들이 랜덤하지 않다.
만약 키 들의 통계적 분포에 대해 알고 있다면 이를 이용해서 해쉬 함수를 고안하는 것이 가능하겠지만 현실적으로 어렵다.
키들이 어떤 특정한 (가시적인) 패턴을 가지더라도 해쉬함수 값이 불규칙적이 되도록 하는것이 바람직하다.
- 해쉬 함수의 값이 키의 특정 부분에 의해서만 결정되지 않아야 한다.(키의 모든 부분이 해쉬 함수 결과값을 도출하는데 쓰이는 것이 바람직하다.)

전형적인 해쉬 함수 기법(거의 모든 해쉬 함수들이 일반적으로 가장 마지막 스텝으로 하는 과정)
Division 기법
- h(k) = k mod m (이 식 하나만으로 해쉬 함수를 처리하는 경우는 없다고 봐도 무방하다.)
- 예 : m = 20 and k = 91 => h(k) = 11
- 장점 : 한번의 mod 연산으로 계산한다. 따라서 빠르다.
- 단점 : 어떤 m 값에 대해서는 해쉬 함수값이 키 값의 특정 부분에 의해서 결정되는 경우가 있다.
가령 m = 2^p 이면 키의 하위 p 비트가 해쉬 함수값이 된다.

Multilplication 기법(최종적으로 소수 부분을 활용하고 키 값의 모든 부분을 사용하는 것으로 인해 예측하기 어려운 값이 나온다.)
- 0 에서 1 사이의 상수 A 를 선택한다. : 0 < A < 1
- kA 의 소수부분 만을 택한다.(k : 키 값)
- 소수 부분에 m 을 곱한 후 소수점 아래를 버린다.
예시 : m = 8, word size = w = 5, k = 21
- A = 13 / 32 를 선택한다.
- kA = 21 * 13 / 32 = 273 / 32 = 8 + 17 / 32
- m (kA mod 1) = 8 * 17 / 32 = 17 / 4 = 4, ......
- 즉, h(21) = 4
Multilpication 기법 뿐만이 아니라 다른 여러가지 기법 또한 존재한다.


Hashing in Java
- Java 의 Object class 는 hashCode() method 를 가진다. 따라서 모든 클래스는 hashCode() method 를 상속받는다. 이 메소드는 하나의 32비트 정수를 반환한다.(음수 일수도 있다.)
- 만약 x.equals(y) 이면 x.hashCode() == y.hashCode() 이다. 하지만 역은 성립하지 않는다.(두 개의 키가 동일하다면 당연히 두 키의 해쉬 함수 값이 동일하다. 하지만 해쉬함수 값이 동일하다고 해서 반드시 키 값이 동일하는 것은 아니다. - 완전히 동일하다면 충돌이 일어날 수 없다.)
- Object class 의 hashCode() method 는 객체의 메모리 주소를 반환하는 것으로 알려져 있다.(but it's implementation-dependent) //구현 의존적이다?
해당 내용은 확실히는 모른다.
- 필요에 따라 각 클래스마다 이 메소드를 override 하여 사용한다.
예시 : Integer class 는 정수값을 hashCode 로 사용한다.

해쉬 함수의 예 : hashCode() for Strings in Java
public final class String
{
	private final char[] s;
	...
	...

	public int hashCode()
	{
		int hash = 0;
		for(int i = 0; i < length(); i++)
			hash = s[i] + (31 * hash);
		return hash;
	}
}
h(s) = 31^L-1 * s0 + .....+ 31 * sL-2 + 31^0 * sL-1
String = s0, s1, s1.....(s : unicode)

사용자 정의 클래스의 예
public class Record
{
	private String name;
	private int id;
	private double value;
	...
	public int hashCode() { //hashCode method 를 override 해주지 않으면 Object class 의 default hashCode method 가 사용되어진다.
		int hash = 17; // nonzero constant
		hash = 31 * hash + name.hashCode(); //String class 내부의 hashCode method
		hash = 31 * hash + Integer.valueOf(id).hashCode(); //Integer class 내부의 hashCode method
		hash = 31 * hash + Double.valueOf(value).hashCode(); //Double class 내부의 hashCode method
		return hash;
	}
} //모든 멤버들을 사용하여 hashCode 를 생성한다.

hashCode 와 hash 함수
- hash code : -2^31 에서 2^31 사이의 정수(임의의 32비트 정수) - 테이블 사이즈가 얼마인지 모르는 상태에서 임의의 코드 값을 넘겨준다.(이것을 다시 내가 원하는 배열 인덱스로 변환해주는 함수가 필요하다.)
- hash 함수 : 0 에서 M - 1 까지의 정수(배열 인덱스)
private int hash(Key key)
{
	return (key.hashCode() & 0x7fffffff) % M; // key.hashCode() : 임의의 32비트 정수, 0x7fffffff : 011111....111 인 32비트 정수
	// % M 을 해주는 이유? : 32비트 정수가 뭐든간에 첫 비트가 0 이 된다. -> 해쉬 코드를 양수로 바꿔준다. 
}

HashMap in Java(Container class)
- TreeMap class 와 유사한 인터페이스를 제공한다.(둘 다 java.util.Map 인터페이스를 구현한다.)
- 내부적으로 하나의 배열을 해쉬 테이블로 사용한다.
- 해쉬 함수는 위의 private int hash 함수와 유사하다. 
- chaining 으로 충돌을 해결한다.
- load factor 를 지정할 수 있다.(0 ~ 1 사이의 실수) (배열의 크기 또한 지정할 수 있다.)
- 저장된 키의 개수가 load factor 를 초과하면 더 큰 배열을 할당하고 저장된 키들을 재배치(re-hashing)한다.
- key 의 갯수 > 배열크기 * load factor 라면 Array reallocation 을 통해 배열의 크기를 더 늘려준다.(M 값이 달라지므로 원래 해싱으로 저장되었던 키들을 다시 해싱해서 새로운 배열로 옮기는 작업이 있어야 한다.)

HashSet in Java
HashSet<MyKey> set = new HashSet<MyKey>(); //set : 집합 abstract data type 을 구현하는 클래스(add, remove, contains(검사)) 
set.add(MyKey);
if(set.contains(theKey))
....
int k = set.size();
set.remove(theKey);
Iterator<MyKey> it = set.iterator(); //iterator 또한 제공
while(it.hasNext()){
	MyKey key = it.next();
	if(key.equals(aKey))
		it.remove();
}